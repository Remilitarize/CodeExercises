[toc]

## 第几天（5 分）

2000 年的 1 月 1 日，是那一年的第 1 天。
那么，2000 年的 5 月 4 日，是那一年的第几天？

***思路：***

手算题（划）。

```cpp
#include<cstdio>
using namespace std;

int day[] = {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

int main(){
	int sum = 0;
	
	for(int i = 1; i < 5; i ++){
		sum += day[i];
	}
	printf("%d\n", sum + 4);
	
    return 0;
}
```

## 明码（7 分）

汉字的字形存在于字库中，即便在今天，16 点阵的字库也仍然使用广泛。
16点阵的字库把每个汉字看成是 16*16 个像素信息。并把这些信息记录在字节中。

一个字节可以存储 8 位信息，用 32 个字节就可以存一个汉字的字形了。
把每个字节转为 2 进制表示，1 表示墨迹，0 表示底色。每行 2 个字节，
一共 16 行，布局是：

- 第 1 字节，第 2 字节
- 第 3 字节，第 4 字节
- ....
- 第 31 字节, 第 32 字节

这道题目是给你一段多个汉字组成的信息，每个汉字用 32 个字节表示，这里给出了字节作为有符号整数的值。

题目的要求隐藏在这些信息中。你的任务是复原这些汉字的字形，从中看出题目的要求，并根据要求填写答案。

这段信息是（一共 10 个汉字）：

```
4 0 4 0 4 0 4 32 -1 -16 4 32 4 32 4 32 4 32 4 32 8 32 8 32 16 34 16 34 32 30 -64 0 
16 64 16 64 34 68 127 126 66 -124 67 4 66 4 66 -124 126 100 66 36 66 4 66 4 66 4 126 4 66 40 0 16 
4 0 4 0 4 0 4 32 -1 -16 4 32 4 32 4 32 4 32 4 32 8 32 8 32 16 34 16 34 32 30 -64 0 
0 -128 64 -128 48 -128 17 8 1 -4 2 8 8 80 16 64 32 64 -32 64 32 -96 32 -96 33 16 34 8 36 14 40 4 
4 0 3 0 1 0 0 4 -1 -2 4 0 4 16 7 -8 4 16 4 16 4 16 8 16 8 16 16 16 32 -96 64 64 
16 64 20 72 62 -4 73 32 5 16 1 0 63 -8 1 0 -1 -2 0 64 0 80 63 -8 8 64 4 64 1 64 0 -128 
0 16 63 -8 1 0 1 0 1 0 1 4 -1 -2 1 0 1 0 1 0 1 0 1 0 1 0 1 0 5 0 2 0 
2 0 2 0 7 -16 8 32 24 64 37 -128 2 -128 12 -128 113 -4 2 8 12 16 18 32 33 -64 1 0 14 0 112 0 
1 0 1 0 1 0 9 32 9 16 17 12 17 4 33 16 65 16 1 32 1 64 0 -128 1 0 2 0 12 0 112 0 
0 0 0 0 7 -16 24 24 48 12 56 12 0 56 0 -32 0 -64 0 -128 0 0 0 0 1 -128 3 -64 1 -128 0 0
```

***思路：***

两个数一组进行输出。
这里 1 用 `*` 表示，0 用 `.` 表示。

【这里将图案输出到文件中。】

```cpp
#include<cstdio>
using namespace std;

int binary[17];

int main(){
	
	freopen("out.txt", "w", stdout);
	int a, b;
	for(int i = 1; i <= 16*10; i ++){
		scanf("%d%d", &a, &b);
		for(int j = 8; j >= 1; j --){
			binary[j] = a % 2;
			a >>= 1;
		}
		for(int j = 16; j >= 9; j --){
			binary[j] = b % 2;
			b >>= 1;
		}
		
		for(int j = 1; j <= 16; j ++){
			printf("%c", binary[j] == 0? '.': '*');
		}
		printf("\n");
		
		if(i % 16 == 0){
			printf("\n");
		}
	}
    return 0;
}
```

## 乘积尾零（13 分）

如下的 10 行数据，每行有 10 个整数，请你求出它们的乘积的末尾有多少个零？

```
5650 4542 3554 473 946 4114 3871 9073 90 4329 
2758 7949 6113 5659 5245 7432 3051 4434 6704 3594 
9937 1173 6866 3397 4759 7557 3070 2287 1453 9899 
1486 5722 3135 1170 4014 5510 5120 729 2880 9019 
2049 698 4582 4346 4427 646 9742 7340 1230 7683 
5693 7015 6887 7381 4172 4341 2909 2027 7355 5649 
6701 6645 1671 5978 2704 9926 295 3125 3878 6785 
2066 4247 4800 1578 6652 4616 1113 6205 3264 2915 
3966 5291 2904 1285 2193 1428 2265 8730 9436 7074 
689 5510 8243 6114 337 4096 8199 7313 3685 211
```

***思路：***

阶乘尾零的变种，当且仅当 2 的倍数乘以 5 的倍数时才能产生尾 0。

统计 5、25、125、625 的倍数，其中

- 每一个 5 的倍数乘以 2 的倍数，尾零加 1。
- 每一个 25 的倍数乘以 4 的倍数，尾零加 2。
- 以此类推。

```cpp
#include<cstdio>
using namespace std;
int count1 = 0;
int count2 = 0;

void f1(int a){
	while(a && a % 5 == 0){
		count1 ++;
		a /= 5;
	}
}

void f2(int a){
	while(a && a % 2 == 0){
		count2 ++;
		a /= 5;
	}
}

int main(){
	
	int temp;
	for(int i = 1; i <= 100; i ++){
		scanf("%d", &temp);
		if(temp % 5 == 0){
			f1(temp);
			f2(temp;)
		}
	}
	
	printf("%d\n", count1 > count2? count1 : count2);
	
    return 0;
}
```

## 测试次数（17 分）

x 星球的居民脾气不太好，但好在他们生气的时候唯一的异常举动是：摔手机。
各大厂商也就纷纷推出各种耐摔型手机。
x 星球的质监局规定了手机必须经过耐摔测试，并且评定出一个耐摔指数来，之后才允许上市流通。

x 星球有很多高耸入云的高塔，刚好可以用来做耐摔测试。
塔的每一层高度都是一样的，与地球上稍有不同的是，他们的第一层不是地面，而是相当于我们的 2 楼。

如果手机从第 7 层扔下去没摔坏，但第 8 层摔坏了，则手机耐摔指数 = 7。
特别地，如果手机从第 1 层扔下去就坏了，则耐摔指数 = 0。
如果到了塔的最高层第 n 层扔没摔坏，则耐摔指数 = n。

为了减少测试次数，从每个厂家抽样 3 部手机参加测试。

某次测试的塔高为 1000 层，如果我们总是采用最佳策略，
在最坏的运气下最多需要测试多少次才能确定手机的耐摔指数呢？

请填写这个最多测试次数。

## 快速排序（9 分）

```cpp
#include <stdio.h>

int quick_select(int a[], int l, int r, int k) {
	int p = rand() % (r - l + 1) + l;
	int x = a[p];
	{int t = a[p]; a[p] = a[r]; a[r] = t;}
	int i = l, j = r;
	while(i < j) {
		while(i < j && a[i] < x) i++;
		if(i < j) {
			a[j] = a[i];
			j--;
		}
		while(i < j && a[j] > x) j--;
		if(i < j) {
			a[i] = a[j];
			i++;
		}
	}
	a[i] = x;
	p = i;
	if(i - l + 1 == k) return a[i];
	if(i - l + 1 < k) return quick_select( _____________________________ ); //填空
	else return quick_select(a, l, i - 1, k);
}
	
int main()
{
	int a[] = {1, 4, 2, 8, 5, 7, 23, 58, 16, 27, 55, 13, 26, 24, 12};
	printf("%d\n", quick_select(a, 0, 14, 5));
	return 0;
}
```

**答案：`a, i + 1, r, k-(i-l+1)`**

## 递增三元组（11 分）

给定三个整数数组
A = [A1, A2, ... AN], 
B = [B1, B2, ... BN], 
C = [C1, C2, ... CN]，

请你统计有多少个三元组(i, j, k) 满足：

1. 1 &le; i, j, k &le; N  
2. Ai < Bj < Ck  

**输入格式**

第一行包含一个整数 N。
第二行包含 N 个整数 A1, A2, ... AN。
第三行包含 N 个整数 B1, B2, ... BN。
第四行包含 N 个整数 C1, C2, ... CN。

对于 30% 的数据，1 &le; N &le; 100  
对于 60% 的数据，1 &le; N &le; 1000 
对于 100% 的数据，1 &le; N &le; 100000 0 &le; Ai, Bi, Ci &le; 100000 

**输出格式**

一个整数表示答案

**样例输入**

```
3
1 1 1
2 2 2
3 3 3
```

**样例输出**

27 

***思路：***

A / C 排序。
二分查找 A 中小于 B 的以及 C 中大于 B 的，两者的乘积累加。

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;

const int maxn = 100000 + 5;
int a[maxn];
int b[maxn];
int c[maxn];

int main(){

	int n;
	scanf("%d", &n);
	
	for(int i = 0; i < n; i ++){
		scanf("%d", &a[i]);
	}
	for(int i = 0; i < n; i ++){
		scanf("%d", &b[i]);
	}
	for(int i = 0; i < n; i ++){
		scanf("%d", &c[i]);
	}
	
	sort(a, a+n);
	sort(c, c+n);
	
	long long ans = 0;
	for(int i = 0; i < n; i ++){
		ans += (lower_bound(a, a+n, b[i]) - a) * (n - (lower_bound(c, c+n, b[i]) - c));
	}
	
	printf("%I64d\n", ans);

	return 0;
}
```

## 螺旋折线（19 分）

![螺旋折线](http://oxnec2zdn.bkt.clouddn.com/lanqiaobeidijiujie/luoxuanzhexian.png)

如图所示的螺旋折线经过平面上所有整点恰好一次。

对于整点 (X, Y)，我们定义它到原点的距离 dis(X, Y) 是从原点到 (X, Y) 的螺旋折线段的长度。  

例如 dis(0, 1) = 3, dis(-2, -1) = 9。

给出整点坐标 (X, Y)，你能计算出 dis(X, Y) 吗？

**输入格式**

X  Y  

对于 40% 的数据，-1000 &le; X, Y &le; 1000  
对于 70% 的数据，-100000 &le; X， Y &le; 100000  
对于 100% 的数据, -1000000000 &le; X, Y &le; 1000000000  

**输出格式**

输出 dis(X, Y)  

**样例输入**

0 1

**样例输出**

3

***思路：***

- 对于第三象限，起始为 1（2 - 1），每次增大一圈加 2。
- 对于第二象限，起始为 2，每次增大一圈加 2。
- 对于第一象限，起始为 2，每次增大一圈加 2。
- 对于第四象限，起始为 2，每次增大一圈加 2。

```cpp

```

## 日志统计（21 分）

小明维护着一个程序员论坛。现在他收集了一份 "点赞" 日志，日志共有 N 行。
其中每一行的格式是：

`ts id`  

表示在 ts 时刻编号 id 的帖子收到一个 "赞"。  

现在小明想统计有哪些帖子曾经是 "热帖"。
如果一个帖子曾在任意一个长度为 D 的时间段内收到不少于 K 个赞，
小明就认为这个帖子曾是 "热帖"。  

具体来说，如果存在某个时刻T满足该帖在 [T, T+D) 这段时间内（注意是左闭右开区间）收到不少于 K 个赞，该帖就曾是 "热帖"。  

给定日志，请你帮助小明统计出所有曾是 "热帖" 的帖子编号。  

**输入格式**
第一行包含三个整数 N、D 和 K。  
以下 N 行每行一条日志，包含两个整数 ts 和 id。  

对于 50% 的数据，1 &le; K &le; N &le; 1000  
对于 100% 的数据，1 &le; K &le; N &le; 100000，0 &le; ts &le; 100000，0 &le; id &le; 100000  

**输出格式**
按从小到大的顺序输出热帖 id。每个 id 一行。  

**输入样例**

```
7 10 2  
0 1  
0 10    
10 10  
10 1  
9 1
100 3  
100 3 
```

**输出样例**

```
1  
3  
```

***思路：***
暂空

## 全球变暖（23 分）

你有一张某海域 N*N 像素的照片，"." 表示海洋、"#" 表示陆地，如下所示：

```
.......
.##....
.##....
....##.
..####.
...###.
.......
```

其中 "上下左右" 四个方向上连在一起的一片陆地组成一座岛屿。例如上图就有 2 座岛屿。  

由于全球变暖导致了海面上升，科学家预测未来几十年，岛屿边缘一个像素的范围会被海水淹没。
具体来说如果一块陆地像素与海洋相邻（上下左右四个相邻像素中有海洋），它就会被淹没。  

例如上图中的海域未来会变成如下样子：

```
.......
.......
.......
.......
....#..
.......
.......
```

请你计算：依照科学家的预测，照片中有多少岛屿会被完全淹没。  

**输入格式**
第一行包含一个整数 N。（1 &le; N &le; 1000）
以下 N 行 N 列代表一张海域照片。  

照片保证第 1 行、第 1 列、第 N 行、第 N 列的像素都是海洋。  

**输出格式**
一个整数表示答案。

**输入样例**

```
7 
.......
.##....
.##....
....##.
..####.
...###.
.......
```

**输出样例**
1

***思路：***
典型 BFS 题目。
利用 BFS 对岛屿进行编号，再模拟被水淹后的结果，统计剩余岛屿数。
注意有可能岛屿上有类似山峰地形的地方，会形成两个岛屿，所以需要对统计出来的结果去重。

```cpp
#include<cstdio>
#include<cstring>
#include<queue>
#include<set>
using namespace std;

struct node{
	int x;
	int y;
};

int n;
const int maxn = 1000 + 5;
char map[maxn][maxn];
int island[maxn][maxn];

int count = 0;
queue<node> q;
set<int> s;

int x[] = {0, 1, 0, -1};
int y[] = {1, 0, -1, 0};

void bfs(){
	node temp;
	while(!q.empty()){
		temp = q.front();
		q.pop();
		island[temp.x][temp.y] = count;

		int xx, yy;
		for(int i = 0; i < 4; i ++){
			xx = temp.x + x[i];
			yy = temp.y + y[i];
			if(xx >= 0 && xx < n && yy >= 0 && yy < n && 
				map[xx][yy] == '#' && island[xx][yy] == 0){
				q.push((node){xx, yy});
			}
		}
	}
}

int main()
{
	memset(island, 0, sizeof(island));

	scanf("%d", &n);
	
	for(int i = 0; i < n; i ++){
		scanf("%s", map[i]);
	}
	
	for(int i = 0; i < n; i ++){
		for(int j = 0; j < n; j ++){
			if(map[i][j] == '#' && island[i][j] == 0){
				count ++;
				q.push((node){i, j});
				bfs();
			}
		}
	}
	
	for(int i = 0; i < n; i ++){
		for(int j = 0; j < n; j ++){
			int xx, yy;
			for(int k = 0; map[i][j] == '#' && k < 4; k ++){
				xx = i + x[k];
				yy = j + y[k];
				if(xx >= 0 && xx < n && yy >= 0 && yy < n && map[xx][yy] == '.'){
					island[i][j] = 0;
					break;
				}
			}
		}
	}
	
	for(int i = 0; i < n; i ++){
		for(int j = 0; j < n; j ++){
			if(island[i][j] != 0){
				s.insert(island[i][j]);
			}
		}
	}
	
	printf("%d\n", count - s.size());
		
    return 0;
}
```

## 乘积最大（25 分）

给定 N 个整数 A1, A2, ... AN。请你从中选出 K 个数，使其乘积最大。  

请你求出最大的乘积，由于乘积可能超出整型范围，你只需输出乘积除以 1000000009 的余数。  

注意，如果 X < 0， 我们定义 X 除以 1000000009 的余数是负（-X）除以 1000000009 的余数。
即：`0-((0-x) % 1000000009)`

**输入格式**
第一行包含两个整数 N 和 K。  
以下 N 行每行一个整数 Ai。  

对于 40% 的数据，1 &le; K &le; N &le; 100  
对于 60% 的数据，1 &le; K &le; 1000  
对于 100% 的数据，1 &le; K &le; N &le;100000，-100000 &le; Ai &le; 100000  

**输出格式**
一个整数，表示答案。

**输入样例**

```
5 3 
-100000   
-10000   
2   
100000  
10000 
```

**输出样例**

```
999100009
```

再例如：

**输入样例**

```
5 3 
-100000   
-100000   
-2   
-100000  
-100000
```

**输出样例**

```
-999999829
```

***思路：***
暂空
