[toc]

## 煤球数目（3 分）

有一堆煤球，堆成三角棱锥形。具体：
第一层放 1 个，
第二层 3 个（排列成三角形），
第三层 6 个（排列成三角形），
第四层 10 个（排列成三角形），
....
如果一共有 100 层，共有多少个煤球？

***思路：***

每层规律满足下面公式：

- A<sub>n</sub> = 1 (n = 1)
- A<sub>n</sub> = A<sub>n-1</sub> + n (n &gt; 1)

注意是问所有层的总数。

```java

```

## 生日蜡烛（5 分）

某君从某年开始每年都举办一次生日 party，并且每次都要吹熄与年龄相同根数的蜡烛。
现在算起来，他一共吹熄了 236 根蜡烛。
请问，他从多少岁开始过生日 party 的？

请填写他开始过生日 party 的年龄数。

***思路：***

从 1 岁开始枚举年龄，一旦超过 236 就从 2 岁开始枚举，以此类推。

```java

```

## 凑算式（9 分）

```
    B   DEF
A + — + ——— = 10
    C   GHI
```

这个算式中 A~I 代表 1~9 的数字，不同的字母代表不同的数字。

比如：
6+8/3+952/714 就是一种解法，
5+3/1+972/486 是另一种解法。

这个算式一共有多少种解法？

***思路：***

不用想太多，直接枚举各个字母可能填的数字即可。

注意一个字母对应一个数字，所以不要选重复数字，使用标记数组标记。
如果之前有字母使用了数字直接跳过，否则可以使用这个数字，标记并继续循环。
使用过这个数字后，记得要放回数字。

为了避免除法，可以将等式变换成下面的形式。
A&sdot;C&sdot;GHI + B&sdot;GHI + DEF&sdot;C = 10&sdot;C&sdot;GHI

## 分小组（11 分）

9 名运动员参加比赛，需要分3组进行预赛。
有哪些分组的方案呢？

我们标记运动员为 A，B，C，... I。
下面的程序列出了所有的分组方法。

该程序的正常输出为：

ABC DEF GHI
ABC DEG FHI
ABC DEH FGI
ABC DEI FGH
ABC DFG EHI
ABC DFH EGI
ABC DFI EGH
ABC DGH EFI
ABC DGI EFH
ABC DHI EFG
ABC EFG DHI
ABC EFH DGI
ABC EFI DGH
ABC EGH DFI
ABC EGI DFH
ABC EHI DFG
ABC FGH DEI
ABC FGI DEH
ABC FHI DEG
ABC GHI DEF
ABD CEF GHI
ABD CEG FHI
ABD CEH FGI
ABD CEI FGH
ABD CFG EHI
ABD CFH EGI
ABD CFI EGH
ABD CGH EFI
ABD CGI EFH
ABD CHI EFG
ABD EFG CHI
..... (以下省略，总共560行)。

```java
public class A
{
	public static String remain(int[] a)
	{
		String s = "";
		for(int i=0; i<a.length; i++){
			if(a[i] == 0) s += (char)(i+'A');
		}	
		return s;
	}
	
	public static void f(String s, int[] a)
	{
		for(int i=0; i<a.length; i++){
			if(a[i]==1) continue;
			a[i] = 1;
			for(int j=i+1; j<a.length; j++){
				if(a[j]==1) continue;
				a[j]=1;
				for(int k=j+1; k<a.length; k++){
					if(a[k]==1) continue;
					a[k]=1;
					System.out.println(__________________________________);  //填空位置
					a[k]=0;
				}
				a[j]=0;
			}
			a[i] = 0;
		}
	}
	
	public static void main(String[] args)
	{
		int[] a = new int[9];		
		a[0] = 1;
		
		for(int b=1; b<a.length; b++){
			a[b] = 1;
			for(int c=b+1; c<a.length; c++){
				a[c] = 1;
				String s = "A" + (char)(b+'A') + (char)(c+'A');
				f(s,a);
				a[c] = 0;
			}
			a[b] = 0;
		}
	}
}
```

## 抽签（13 分）

X 星球要派出一个 5 人组成的观察团前往 W 星。
其中：

- A 国最多可以派出 4 人。
- B 国最多可以派出 2 人。
- C 国最多可以派出 2 人。
- ....

那么最终派往 W 星的观察团会有多少种国别的不同组合呢？

下面的程序解决了这个问题。
数组 a[] 中既是每个国家可以派出的最多的名额。
程序执行结果为：
DEFFF
CEFFF
CDFFF
CDEFF
CCFFF
CCEFF
CCDFF
CCDEF
BEFFF
BDFFF
BDEFF
BCFFF
BCEFF
BCDFF
BCDEF
....
（以下省略，总共101行）

```java
public class A
{
	public static void f(int[] a, int k, int n, String s)
	{
		if(k==a.length){ 
			if(n==0) System.out.println(s);
			return;
		}
		
		String s2 = s;
		for(int i=0; i<=a[k]; i++){
			_____________________________;   //填空位置
			s2 += (char)(k+'A');
		}
	}
	
	public static void main(String[] args)
	{
		int[] a = {4,2,2,1,1,3};
		
		f(a,0,5,"");
	}
}
```

## 方格填数（15 分）

如下的 10 个格子填入 0~9 的数字。

![方格填数](http://oxnec2zdn.bkt.clouddn.com/lanqiaobeidiqijie/fanggetianshu.jpg)

要求：连续的两个数字不能相邻。
（左右、上下、对角都算相邻）

一共有多少种可能的填数方案？

***思路：***

将方格进行标号。

```
    +---+---+---+
    | 0 | 1 | 2 |
+---+---+---+---+
| 3 | 4 | 5 | 6 |
+---+---+---+---+
| 7 | 8 | 9 |
+---+---+---+
```

同凑算式。
枚举总共有多少种排列，分别填进格中，对条件进行判断。
（这里假设数字不可重复。）

## 剪邮票（19 分）

![剪邮票 1](http://oxnec2zdn.bkt.clouddn.com/lanqiaobeidiqijie/jianyoupiao1.jpg)

有 12 张连在一起的 12 生肖的邮票。
现在你要从中剪下 5 张来，要求必须是连着的。
（仅仅连接一个角不算相连）

![剪邮票 2](http://oxnec2zdn.bkt.clouddn.com/lanqiaobeidiqijie/jianyoupiao2.jpg)

![剪邮票 3](http://oxnec2zdn.bkt.clouddn.com/lanqiaobeidiqijie/jianyoupiao3.jpg)

如上图中，粉红色所示部分就是合格的剪取。

***思路：***

同方格填数。
这次只需要生成 1~12 中的五个数的排列即可。
为了防止重复，这次生成的时候只允许向比前一个数更大的数中挑选。

找出来后再进行一次 dfs，如果有数字未被访问，则不计数。

## 四平方和（21 分）

四平方和定理，又称为拉格朗日定理：
每个正整数都可以表示为至多 4 个正整数的平方和。
如果把 0 包括进去，就正好可以表示为 4 个数的平方和。

比如：
5 = 0&sup2; + 0&sup2; + 1&sup2; + 2&sup2;
7 = 1&sup2; + 1&sup2; + 1&sup2; + 2&sup2;

对于一个给定的正整数，可能存在多种平方和的表示法。
要求你对 4 个数排序：
0 &le; a &le; b &le; c &le; d
并对所有的可能表示法按 a，b，c，d 为联合主键升序排列，最后输出第一个表示法。

***输入格式：***

一个正整数 N（N &lt; 5000000）

***输出格式：***

输出 4 个非负整数，按从小到大排序，中间用空格分开。

***样例输入 1：**

5

***样例输出 1：***

0 0 1 2

***样例输入 2：***

12

***样例输出 2：***

0 2 2 2

***样例输入 3：***

773535

***样例输出 3：***

1 1 267 838

***思路：***

- 直接四层循环必然超时。
- 推导出 d&sup2;=n-a&sup2;-b&sup2;-c&sup2;，并对 a、b、c 进行遍历，三层循环对于第三个样例仍然很慢。
- 将四个数平方和看作两个数平方和加两个数平方和，对所有两个数平方和打表，并循环 a、b，若 n-a&sup2;-b&sup2; 为一个两个数的平方和，则枚举 c。

## 取球博弈（23 分）

两个人玩取球的游戏。
一共有 N 个球，每人轮流取球，每次可取集合 {n1，n2，n3} 中的任何一个数目。
如果无法继续取球，则游戏结束。
此时，持有奇数个球的一方获胜。
如果两人都是奇数，则为平局。

假设双方都采用最聪明的取法，
第一个取球的人一定能赢吗？
试编程解决这个问题。

***输入格式：***

第一行 3 个正整数 n1 n2 n3，空格分开，表示每次可取的数目（0 &lt; n1，n2，n3 &lt; 100）。
第二行 5 个正整数 x1 x2 ... x5，空格分开，表示5局的初始球数（0 &lt; xi &lt; 1000）。

***输出格式：***

一行 5 个字符，空格分开。分别表示每局先取球的人能否获胜。
能获胜则输出 +，
次之，如有办法逼平对手，输出 0，
无论如何都会输，则输出 -。

***样例输入 1：***

```
1 2 3
1 2 3 4 5
```

***样例输出 1：***

```
+ 0 + 0 -
```

***样例输入 2：***

```
1 4 5
10 11 12 13 15
```

***样例输出 2：***

```
0 - 0 + +
```

***样例输入 3：***

```
2 3 5
7 8 9 10 11
```

***样例输出 3：***

```
+ 0 0 0 0
```

## 压缩变换（31 分）

小明最近在研究压缩算法。
他知道，压缩的时候如果能够使得数值很小，就能通过熵编码得到较高的压缩比。
然而，要使数值很小是一个挑战。

最近，小明需要压缩一些正整数的序列，这些序列的特点是，后面出现的数字很大可能是刚出现过不久的数字。
对于这种特殊的序列，小明准备对序列做一个变换来减小数字的值。

变换的过程如下：

- 从左到右枚举序列，每枚举到一个数字，
- 如果这个数字没有出现过，刚将数字变换成它的相反数。
- 如果数字出现过，则看它在原序列中最后的一次出现后面（且在当前数前面）出现了几种数字，用这个种类数替换原来的数字。

比如，序列 (a1, a2, a3, a4, a5)=(1, 2, 2, 1, 2) 在变换过程为：

- a1: 1 未出现过，所以 a1 变为 -1；
- a2: 2 未出现过，所以 a2 变为 -2；
- a3: 2 出现过，最后一次为原序列的 a2，在 a2 后、a3 前有 0 种数字，所以 a3 变为 0；
- a4: 1 出现过，最后一次为原序列的 a1，在 a1 后、a4 前有 1 种数字，所以 a4 变为 1；
- a5: 2 出现过，最后一次为原序列的 a3，在 a3 后、a5 前有 1 种数字，所以 a5 变为 1。

现在，给出原序列，请问，按这种变换规则变换后的序列是什么。

***输入格式：***

第一行包含一个整数 n，表示序列的长度。（n &lt; 100000，1 &le; ai &le; 10<sup>9</sup>）
第二行包含 n 个正整数，表示输入序列。

***输出格式：***

输出一行，包含 n 个数，表示变换后的序列。

***样例输入 1：***

```
5
1 2 2 1 2
```

***样例输出 1：***

```
-1 -2 0 1 1
```

***样例输入 2：***

```
12
1 1 2 3 2 3 1 2 2 2 3 1
```

***样例输出 2：***

```
-1 0 -2 -3 1 1 2 2 0 0 2 2
```

