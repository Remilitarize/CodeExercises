[toc]

## 有奖猜谜（3 分）

小明很喜欢猜谜语。
最近，他被邀请参加了 X 星球的猜谜活动。

每位选手开始的时候都被发给 777 个电子币。
规则是：猜对了，手里的电子币数目翻倍，
猜错了，扣除 555 个电子币, 扣完为止。

小明一共猜了 15 条谜语。
战果为：`vxvxvxvxvxvxvvx`。
其中 v 表示猜对了，x 表示猜错了。

请你计算一下，小明最后手里的电子币数目是多少。

请填写表示最后电子币数目的数字。

## 煤球数目（5 分）

有一堆煤球，堆成三角棱锥形。具体：
第一层放 1 个，
第二层 3 个（排列成三角形），
第三层 6 个（排列成三角形），
第四层 10 个（排列成三角形），
....
如果一共有 100 层，共有多少个煤球？

***思路：***

每层规律满足下面公式：

- A<sub>n</sub> = 1 (n = 1)
- A<sub>n</sub> = A<sub>n-1</sub> + n (n &gt; 1)

注意是问所有层的总数。

```java

```

## 平方怪圈（7 分）

如果把一个正整数的每一位都平方后再求和，得到一个新的正整数。
对新产生的正整数再做同样的处理。

如此一来，你会发现，不管开始取的是什么数字，
最终如果不是落入 1，就是落入同一个循环圈。

请写出这个循环圈中最大的那个数字。

请填写该最大数字。

***思路：***

依次对出现过的数字进行标记数字。
由于我们的初始值只要不为 1，就一定会进入循环圈中，那么存在我们所举出的数本身并不在循环体内。
所以需要从任意一个数开始运算，直到某个数出现了三次（也就是刚开始循环一圈，然后自己循环一圈）停止。
统计出现两次或两次以上的数字中最大的数即可。

## 骰子游戏（11 分）

我们来玩一个游戏。
同时掷出 3 个普通骰子（6 个面上的数字分别是 1~6）。
如果其中一个骰子上的数字等于另外两个的和，你就赢了。

下面的程序计算出你能获胜的精确概率（以既约分数表示）

```java
public class Main
{
	public static int gcd(int a, int b)
	{
		if(b==0) return a;
		return gcd(b,a%b);
	}
	
	public static void main(String[] args)
	{	
		int n = 0;
		for(int i=0; i<6; i++)
		for(int j=0; j<6; j++)
		for(int k=0; k<6; k++){
			if(________________________________) n++;   //填空位置
		}
		
		int m = gcd(n,6*6*6);
		System.out.println(n/m + "/" + 6*6*6/m);
	}
}
```

## 分小组（13 分）

9 名运动员参加比赛，需要分3组进行预赛。
有哪些分组的方案呢？

我们标记运动员为 A，B，C，... I。
下面的程序列出了所有的分组方法。

该程序的正常输出为：

ABC DEF GHI
ABC DEG FHI
ABC DEH FGI
ABC DEI FGH
ABC DFG EHI
ABC DFH EGI
ABC DFI EGH
ABC DGH EFI
ABC DGI EFH
ABC DHI EFG
ABC EFG DHI
ABC EFH DGI
ABC EFI DGH
ABC EGH DFI
ABC EGI DFH
ABC EHI DFG
ABC FGH DEI
ABC FGI DEH
ABC FHI DEG
ABC GHI DEF
ABD CEF GHI
ABD CEG FHI
ABD CEH FGI
ABD CEI FGH
ABD CFG EHI
ABD CFH EGI
ABD CFI EGH
ABD CGH EFI
ABD CGI EFH
ABD CHI EFG
ABD EFG CHI
..... (以下省略，总共560行)。

```java
public class A
{
	public static String remain(int[] a)
	{
		String s = "";
		for(int i=0; i<a.length; i++){
			if(a[i] == 0) s += (char)(i+'A');
		}	
		return s;
	}
	
	public static void f(String s, int[] a)
	{
		for(int i=0; i<a.length; i++){
			if(a[i]==1) continue;
			a[i] = 1;
			for(int j=i+1; j<a.length; j++){
				if(a[j]==1) continue;
				a[j]=1;
				for(int k=j+1; k<a.length; k++){
					if(a[k]==1) continue;
					a[k]=1;
					System.out.println(__________________________________);  //填空位置
					a[k]=0;
				}
				a[j]=0;
			}
			a[i] = 0;
		}
	}
	
	public static void main(String[] args)
	{
		int[] a = new int[9];		
		a[0] = 1;
		
		for(int b=1; b<a.length; b++){
			a[b] = 1;
			for(int c=b+1; c<a.length; c++){
				a[c] = 1;
				String s = "A" + (char)(b+'A') + (char)(c+'A');
				f(s,a);
				a[c] = 0;
			}
			a[b] = 0;
		}
	}
}
```

## 凑算式（15 分）

```
    B   DEF
A + — + ——— = 10
    C   GHI
```

这个算式中 A~I 代表 1~9 的数字，不同的字母代表不同的数字。

比如：
6+8/3+952/714 就是一种解法，
5+3/1+972/486 是另一种解法。

这个算式一共有多少种解法？

***思路：***

不用想太多，直接枚举各个字母可能填的数字即可。

注意一个字母对应一个数字，所以不要选重复数字，使用标记数组标记。
如果之前有字母使用了数字直接跳过，否则可以使用这个数字，标记并继续循环。
使用过这个数字后，记得要放回数字。

为了避免除法，可以将等式变换成下面的形式。
A&sdot;C&sdot;GHI + B&sdot;GHI + DEF&sdot;C = 10&sdot;C&sdot;GHI

## 搭积木（19 分）

小明最近喜欢搭数字积木，
一共有 10 块积木，每个积木上有一个数字，0~9。

搭积木规则：
每个积木放到其它两个积木的上面，并且一定比下面的两个积木数字小。
最后搭成 4 层的金字塔形，必须用完所有的积木。

下面是两种合格的搭法：

```
   0
  1 2
 3 4 5
6 7 8 9

   0
  3 1
 7 5 2
9 8 6 4
``` 

请你计算这样的搭法一共有多少种？

## 冰雹数（21 分）

任意给定一个正整数 N，
如果是偶数，执行：N / 2
如果是奇数，执行：N * 3 + 1

生成的新的数字再执行同样的动作，循环往复。

通过观察发现，这个数字会一会儿上升到很高，
一会儿又降落下来。
就这样起起落落的，但最终必会落到 "1"。
这有点像小冰雹粒子在冰雹云中翻滚增长的样子。

比如 N = 9
9,28,14,7,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2,1
可以看到，N = 9 的时候，这个 "小冰雹" 最高冲到了 52 这个高度。

***输入格式：***

一个正整数 N（N &lt; 1000000）

***输出格式：***

一个正整数，表示不大于 N 的数字，经过冰雹数变换过程中，最高冲到了多少。

***样例输入 1：***

10

***样例输出 1：***

52

***样例输入 2：***

100

***样例输出 2：***

9232

***思路：***

2n + 1 问题换了个描述而已。
按照题目描述，循环到该数字变为 1 位置，记录变化过程中数字的最大值即可。
注意是不大于 N。

## 四平方和（25 分）

四平方和定理，又称为拉格朗日定理：
每个正整数都可以表示为至多 4 个正整数的平方和。
如果把 0 包括进去，就正好可以表示为 4 个数的平方和。

比如：
5 = 0&sup2; + 0&sup2; + 1&sup2; + 2&sup2;
7 = 1&sup2; + 1&sup2; + 1&sup2; + 2&sup2;

对于一个给定的正整数，可能存在多种平方和的表示法。
要求你对 4 个数排序：
0 &le; a &le; b &le; c &le; d
并对所有的可能表示法按 a，b，c，d 为联合主键升序排列，最后输出第一个表示法。

***输入格式：***

一个正整数 N（N &lt; 5000000）

***输出格式：***

输出 4 个非负整数，按从小到大排序，中间用空格分开。

***样例输入 1：**

5

***样例输出 1：***

0 0 1 2

***样例输入 2：***

12

***样例输出 2：***

0 2 2 2

***样例输入 3：***

773535

***样例输出 3：***

1 1 267 838

***思路：***

- 直接四层循环必然超时。
- 推导出 d&sup2;=n-a&sup2;-b&sup2;-c&sup2;，并对 a、b、c 进行遍历，三层循环对于第三个样例仍然很慢。
- 将四个数平方和看作两个数平方和加两个数平方和，对所有两个数平方和打表，并循环 a、b，若 n-a&sup2;-b&sup2; 为一个两个数的平方和，则枚举 c。

## 密码脱落（31 分）

X 星球的考古学家发现了一批古代留下来的密码。
这些密码是由 A、B、C、D 四种植物的种子串成的序列。
仔细分析发现，这些密码串当初应该是前后对称的（也就是我们说的镜像串）。
由于年代久远，其中许多种子脱落了，因而可能会失去镜像的特征。

你的任务是：
给定一个现在看到的密码串，计算一下从当初的状态，它要至少脱落多少个种子，才可能会变成现在的样子。

***输入格式：***

输入一行，表示现在看到的密码串。（长度不大于 1000）

***输出格式：***

输出一个正整数，表示至少脱落了多少个种子。

***样例输入 1：***

ABCBA

***样例输出 1：***

0

***样例输入 2：***

ABDCDCBABC

***样例输出 2：***

3

***思路：***

贪心。

- 用两个指针指向字符串首尾。
- 当两侧相同时，两个指针向内移动一个位置。
- 当两侧不同时，
    - 分别从两端找与另一端相同的位置。
    - 取小者记录，指针更新。
