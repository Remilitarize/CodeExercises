[toc]

## 煤球数目（3 分）

有一堆煤球，堆成三角棱锥形。具体：
第一层放 1 个，
第二层 3 个（排列成三角形），
第三层 6 个（排列成三角形），
第四层 10 个（排列成三角形），
....
如果一共有 100 层，共有多少个煤球？

***思路：***

每层规律满足下面公式：

- A<sub>n</sub> = 1 (n = 1)
- A<sub>n</sub> = A<sub>n-1</sub> + n (n &gt; 1)

注意是问所有层的总数。

```java

```

## 生日蜡烛（5 分）

某君从某年开始每年都举办一次生日 party，并且每次都要吹熄与年龄相同根数的蜡烛。
现在算起来，他一共吹熄了 236 根蜡烛。
请问，他从多少岁开始过生日 party 的？

请填写他开始过生日 party 的年龄数。

***思路：***

从 1 岁开始枚举年龄，一旦超过 236 就从 2 岁开始枚举，以此类推。

```java

```

## 搭积木（9 分）

小明最近喜欢搭数字积木，
一共有 10 块积木，每个积木上有一个数字，0~9。

搭积木规则：
每个积木放到其它两个积木的上面，并且一定比下面的两个积木数字小。
最后搭成 4 层的金字塔形，必须用完所有的积木。

下面是两种合格的搭法：

```
   0
  1 2
 3 4 5
6 7 8 9

   0
  3 1
 7 5 2
9 8 6 4
``` 

请你计算这样的搭法一共有多少种？

## 分小组（11 分）

9 名运动员参加比赛，需要分3组进行预赛。
有哪些分组的方案呢？

我们标记运动员为 A，B，C，... I。
下面的程序列出了所有的分组方法。

该程序的正常输出为：

ABC DEF GHI
ABC DEG FHI
ABC DEH FGI
ABC DEI FGH
ABC DFG EHI
ABC DFH EGI
ABC DFI EGH
ABC DGH EFI
ABC DGI EFH
ABC DHI EFG
ABC EFG DHI
ABC EFH DGI
ABC EFI DGH
ABC EGH DFI
ABC EGI DFH
ABC EHI DFG
ABC FGH DEI
ABC FGI DEH
ABC FHI DEG
ABC GHI DEF
ABD CEF GHI
ABD CEG FHI
ABD CEH FGI
ABD CEI FGH
ABD CFG EHI
ABD CFH EGI
ABD CFI EGH
ABD CGH EFI
ABD CGI EFH
ABD CHI EFG
ABD EFG CHI
..... (以下省略，总共560行)。

```java
public class A
{
	public static String remain(int[] a)
	{
		String s = "";
		for(int i=0; i<a.length; i++){
			if(a[i] == 0) s += (char)(i+'A');
		}	
		return s;
	}
	
	public static void f(String s, int[] a)
	{
		for(int i=0; i<a.length; i++){
			if(a[i]==1) continue;
			a[i] = 1;
			for(int j=i+1; j<a.length; j++){
				if(a[j]==1) continue;
				a[j]=1;
				for(int k=j+1; k<a.length; k++){
					if(a[k]==1) continue;
					a[k]=1;
					System.out.println(__________________________________);  //填空位置
					a[k]=0;
				}
				a[j]=0;
			}
			a[i] = 0;
		}
	}
	
	public static void main(String[] args)
	{
		int[] a = new int[9];		
		a[0] = 1;
		
		for(int b=1; b<a.length; b++){
			a[b] = 1;
			for(int c=b+1; c<a.length; c++){
				a[c] = 1;
				String s = "A" + (char)(b+'A') + (char)(c+'A');
				f(s,a);
				a[c] = 0;
			}
			a[b] = 0;
		}
	}
}
```

## 抽签（13 分）

X 星球要派出一个 5 人组成的观察团前往 W 星。
其中：

- A 国最多可以派出 4 人。
- B 国最多可以派出 2 人。
- C 国最多可以派出 2 人。
- ....

那么最终派往 W 星的观察团会有多少种国别的不同组合呢？

下面的程序解决了这个问题。
数组 a[] 中既是每个国家可以派出的最多的名额。
程序执行结果为：
DEFFF
CEFFF
CDFFF
CDEFF
CCFFF
CCEFF
CCDFF
CCDEF
BEFFF
BDFFF
BDEFF
BCFFF
BCEFF
BCDFF
BCDEF
....
（以下省略，总共101行）

```java
public class A
{
	public static void f(int[] a, int k, int n, String s)
	{
		if(k==a.length){ 
			if(n==0) System.out.println(s);
			return;
		}
		
		String s2 = s;
		for(int i=0; i<=a[k]; i++){
			_____________________________;   //填空位置
			s2 += (char)(k+'A');
		}
	}
	
	public static void main(String[] args)
	{
		int[] a = {4,2,2,1,1,3};
		
		f(a,0,5,"");
	}
}
```

## 寒假作业（15 分）

现在小学的数学题目也不是那么好玩的。
看看这个寒假作业：

```
□ + □ = □
□ - □ = □
□ × □ = □
□ ÷ □ = □
```
   
每个方块代表 1~13 中的某一个数字，但不能重复。
比如：

```
6  + 7 = 13
9  - 8 = 1
3  * 4 = 12
10 / 2 = 5
```

以及：

```
7  + 6 = 13
9  - 8 = 1
3  * 4 = 12
10 / 2 = 5
```

就算两种解法。（加法，乘法交换律后算不同的方案）
 
你一共找到了多少种方案？

***思路：***

- DFS。
- 每当生成三个数字时就进行判断，减小数据量。
- 先对除法和乘法进行判断，减小数据量。

## 剪邮票（19 分）

![剪邮票 1](http://oxnec2zdn.bkt.clouddn.com/lanqiaobeidiqijie/jianyoupiao1.jpg)

有 12 张连在一起的 12 生肖的邮票。
现在你要从中剪下 5 张来，要求必须是连着的。
（仅仅连接一个角不算相连）

![剪邮票 2](http://oxnec2zdn.bkt.clouddn.com/lanqiaobeidiqijie/jianyoupiao2.jpg)

![剪邮票 3](http://oxnec2zdn.bkt.clouddn.com/lanqiaobeidiqijie/jianyoupiao3.jpg)

如上图中，粉红色所示部分就是合格的剪取。

***思路：***

同方格填数。
这次只需要生成 1~12 中的五个数的排列即可。
为了防止重复，这次生成的时候只允许向比前一个数更大的数中挑选。

找出来后再进行一次 dfs，如果有数字未被访问，则不计数。

## 取球博弈（21 分）

两个人玩取球的游戏。
一共有 N 个球，每人轮流取球，每次可取集合 {n1，n2，n3} 中的任何一个数目。
如果无法继续取球，则游戏结束。
此时，持有奇数个球的一方获胜。
如果两人都是奇数，则为平局。

假设双方都采用最聪明的取法，
第一个取球的人一定能赢吗？
试编程解决这个问题。

***输入格式：***

第一行 3 个正整数 n1 n2 n3，空格分开，表示每次可取的数目（0 &lt; n1，n2，n3 &lt; 100）。
第二行 5 个正整数 x1 x2 ... x5，空格分开，表示5局的初始球数（0 &lt; xi &lt; 1000）。

***输出格式：***

一行 5 个字符，空格分开。分别表示每局先取球的人能否获胜。
能获胜则输出 +，
次之，如有办法逼平对手，输出 0，
无论如何都会输，则输出 -。

***样例输入 1：***

```
1 2 3
1 2 3 4 5
```

***样例输出 1：***

```
+ 0 + 0 -
```

***样例输入 2：***

```
1 4 5
10 11 12 13 15
```

***样例输出 2：***

```
0 - 0 + +
```

***样例输入 3：***

```
2 3 5
7 8 9 10 11
```

***样例输出 3：***

```
+ 0 0 0 0
```

## 交换瓶子（23 分）

有 N 个瓶子，编号 1~N，放在架子上。

比如有 5 个瓶子：
2 1 3 5 4

要求每次拿起 2 个瓶子，交换它们的位置。
经过若干次后，使得瓶子的序号为：
1 2 3 4 5

对于这么简单的情况，显然，至少需要交换 2 次就可以复位。

如果瓶子更多呢？你可以通过编程来解决。

***输入格式：***

第一行：一个正整数 N（N &lt; 10000），表示瓶子的数目
第二行：N 个正整数，用空格分开，表示瓶子目前的排列情况。

***输出格式：***

输出数据为一行一个正整数，表示至少交换多少次，才能完成排序。

***样例输入 1：***

```
5
3 1 2 5 4
```

***样例输出 1：***

3

***样例输入 2：***

```
5
5 4 3 2 1
```

***样例输出 2：***

2

***思路：***

贪心。

- 记录每个位置上的瓶子（数组 bottle），以及瓶子在哪个位置上（数组 pos）。
- 遍历每个位置，如果当前位置上不是对应的瓶子，所以通过 pos 数组找到当前序号的瓶子在哪个位置，并保存（temp）。
- 于是交换当前位置上的瓶子的在 pos 中对应的位置与当前位置对应瓶子的位置（当前位置上的瓶子换新地方），交换当前位置的瓶子与 temp 位置的瓶子（把瓶子换过来）。

## 压缩变换（31 分）

小明最近在研究压缩算法。
他知道，压缩的时候如果能够使得数值很小，就能通过熵编码得到较高的压缩比。
然而，要使数值很小是一个挑战。

最近，小明需要压缩一些正整数的序列，这些序列的特点是，后面出现的数字很大可能是刚出现过不久的数字。
对于这种特殊的序列，小明准备对序列做一个变换来减小数字的值。

变换的过程如下：

- 从左到右枚举序列，每枚举到一个数字，
- 如果这个数字没有出现过，刚将数字变换成它的相反数。
- 如果数字出现过，则看它在原序列中最后的一次出现后面（且在当前数前面）出现了几种数字，用这个种类数替换原来的数字。

比如，序列 (a1, a2, a3, a4, a5)=(1, 2, 2, 1, 2) 在变换过程为：

- a1: 1 未出现过，所以 a1 变为 -1；
- a2: 2 未出现过，所以 a2 变为 -2；
- a3: 2 出现过，最后一次为原序列的 a2，在 a2 后、a3 前有 0 种数字，所以 a3 变为 0；
- a4: 1 出现过，最后一次为原序列的 a1，在 a1 后、a4 前有 1 种数字，所以 a4 变为 1；
- a5: 2 出现过，最后一次为原序列的 a3，在 a3 后、a5 前有 1 种数字，所以 a5 变为 1。

现在，给出原序列，请问，按这种变换规则变换后的序列是什么。

***输入格式：***

第一行包含一个整数 n，表示序列的长度。（n &lt; 100000，1 &le; ai &le; 10<sup>9</sup>）
第二行包含 n 个正整数，表示输入序列。

***输出格式：***

输出一行，包含 n 个数，表示变换后的序列。

***样例输入 1：***

```
5
1 2 2 1 2
```

***样例输出 1：***

```
-1 -2 0 1 1
```

***样例输入 2：***

```
12
1 1 2 3 2 3 1 2 2 2 3 1
```

***样例输出 2：***

```
-1 0 -2 -3 1 1 2 2 0 0 2 2
```

