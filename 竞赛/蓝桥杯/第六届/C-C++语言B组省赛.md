[toc]

## 奖券数目（3 分）

有些人很迷信数字，比如带 "4" 的数字，认为和 "死" 谐音，就觉得不吉利。
虽然这些说法纯属无稽之谈，但有时还要迎合大众的需求。
某抽奖活动的奖券号码是 5 位数（10000-99999），要求其中不要出现带 "4" 的号码。
主办单位请你计算一下，如果任何两张奖券不重号，最多可发出奖券多少张。

## 星系炸弹（5 分）

在 X 星系的广袤空间中漂浮着许多 X 星人造 "炸弹"，用来作为宇宙中的路标。
每个炸弹都可以设定多少天之后爆炸。
比如：阿尔法炸弹 2015 年 1 月 1 日放置，定时为 15 天，则它在 2015 年 1 月 16 日爆炸。
有一个贝塔炸弹，2014 年 11 月 9 日放置，定时为 1000 天，请你计算它爆炸的准确日期。

请填写该日期，格式为 yyyy-mm-dd，即 4 位年份 2 位月份 2 位日期。比如：2015-02-19。
请严格按照格式书写。不能出现其它文字或符号。

## 三羊献瑞（9 分）

观察下面的加法算式：

```
      祥 瑞 生 辉
  +   三 羊 献 瑞
-------------------
   三 羊 生 瑞 气
```

其中，相同的汉字代表相同的数字，不同的汉字代表不同的数字。

请你填写 "三羊献瑞" 所代表的 4 位数字（答案唯一）。

## 格子中输出（11 分）

`StringInGrid` 函数会在一个指定大小的格子中打印指定的字符串。
要求字符串在水平、垂直两个方向上都居中。
如果字符串太长，就截断。
如果不能恰好居中，可以稍稍偏左或者偏上一点。

下面的程序实现这个逻辑，请填写划线部分缺少的代码。

```c
#include <stdio.h>
#include <string.h>

void StringInGrid(int width, int height, const char* s)
{
	int i,k;
	char buf[1000];
	strcpy(buf, s);
	if(strlen(s)>width-2) buf[width-2]=0;
	
	printf("+");
	for(i=0;i<width-2;i++) printf("-");
	printf("+\n");
	
	for(k=1; k<(height-1)/2;k++){
		printf("|");
		for(i=0;i<width-2;i++) printf(" ");
		printf("|\n");
	}
	
	printf("|");
	
	printf("%*s%s%*s",_____________________________________________);  //填空
	          
	printf("|\n");
	
	for(k=(height-1)/2+1; k<height-1; k++){
		printf("|");
		for(i=0;i<width-2;i++) printf(" ");
		printf("|\n");
	}	
	
	printf("+");
	for(i=0;i<width-2;i++) printf("-");
	printf("+\n");	
}

int main()
{
	StringInGrid(20,6,"abcd1234");
	return 0;
}
```

对于题目中数据，应该输出：

```
+------------------+
|                  |
|     abcd1234     |
|                  |
|                  |
+------------------+
```

## 九数组分数（13 分）

1，2，3...9 这九个数字组成一个分数，其值恰好为 1/3，如何组法？

下面的程序实现了该功能，请填写划线部分缺失的代码。

```c
#include <stdio.h>

void test(int x[])
{
	int a = x[0]*1000 + x[1]*100 + x[2]*10 + x[3];
	int b = x[4]*10000 + x[5]*1000 + x[6]*100 + x[7]*10 + x[8];
	
	if(a*3==b) printf("%d / %d\n", a, b);
}

void f(int x[], int k)
{
	int i,t;
	if(k>=9){
		test(x);
		return;
	}
	
	for(i=k; i<9; i++){
		{t=x[k]; x[k]=x[i]; x[i]=t;}
		f(x,k+1);
		_____________________________________________ // 填空处
	}
}
	
int main()
{
	int x[] = {1,2,3,4,5,6,7,8,9};
	f(x,0);	
	return 0;
}
```

## 加法变乘法（17 分）

我们都知道：1 + 2 + 3 + ... + 49 = 1225。
现在要求你把其中两个不相邻的加号变成乘号，使得结果为 2015。

比如：
1 + 2 + 3 + ... + 10 * 11 + 12 + ... + 27 * 28 + 29 + ... + 49 = 2015
就是符合要求的答案。

请你寻找另外一个可能的答案，并把位置靠前的那个乘号左边的数字提交（对于示例，就是提交10）。

## 牌型种数（21 分）

小明被劫持到 X 赌城，被迫与其他 3 人玩牌。
一副扑克牌（去掉大小王牌，共 52 张），均匀发给 4 个人，每个人 13 张。
这时，小明脑子里突然冒出一个问题：
如果不考虑花色，只考虑点数，也不考虑自己得到的牌的先后顺序，自己手里能拿到的初始牌型组合一共有多少种呢？

## 移动距离（15 分）

X 星球居民小区的楼房全是一样的，并且按矩阵样式排列。其楼房的编号为 1，2，3...
当排满一行时，从下一行相邻的楼往反方向排号。
比如：当小区排号宽度为 6 时，开始情形如下：

1  2  3  4  5  6
12 11 10 9  8  7
13 14 15 .....

我们的问题是：已知了两个楼号 m 和 n，需要求出它们之间的最短移动距离（不能斜线方向移动）。

***输入格式：***

3 个整数 w m n，空格分开，都在 1 到 10000 范围内。
w 为排号宽度，m n 为待计算的楼号。

***输出格式：***

要求输出一个整数，表示 m n 两楼间最短移动距离。

***样例输入 1：***

6 8 2

***样例输出 1：***

4

***样例输入 2：***

4 7 20

***样例输出 2：***

5

## 垒骰子（25 分）

赌圣atm晚年迷恋上了垒骰子，就是把骰子一个垒在另一个上边，不能歪歪扭扭，要垒成方柱体。
经过长期观察，atm 发现了稳定骰子的奥秘：有些数字的面贴着会互相排斥！
我们先来规范一下骰子：1 的对面是 4，2 的对面是 5，3 的对面是 6。
假设有 m 组互斥现象，每组中的那两个数字的面紧贴在一起，骰子就不能稳定的垒起来。 
atm 想计算一下有多少种不同的可能的垒骰子方式。
两种垒骰子方式相同，当且仅当这两种方式中对应高度的骰子的对应数字的朝向都相同。
由于方案数可能过多，请输出模 10<sup>9</sup> + 7 的结果。

不要小看了 atm 的骰子数量哦～

***输入格式：***

第一行两个整数 n m（0 &lt; n &le; 10<sup>9</sup>，m &le; 36）
n 表示骰子数目
接下来 m 行，每行两个整数 a b，表示 a 和 b 数字不能紧贴在一起。

***输出格式：***

一行一个数，表示答案模 10<sup>9</sup> + 7 的结果。

***样例输入：***

2 1
1 2

***样例输出：***

544

## 生命之树（31 分）

在 X 森林里，上帝创建了生命之树。

他给每棵树的每个节点（叶子也称为一个节点）上，都标了一个整数，代表这个点的和谐值。
上帝要在这棵树内选出一个非空节点集 S，使得对于 S 中的任意两个点 a，b，都存在一个点列 {a, v1, v2, ..., vk, b} 使得这个点列中的每个点都是 S 里面的元素，且序列中相邻两个点间有一条边相连。

在这个前提下，上帝要使得 S 中的点所对应的整数的和尽量大。
这个最大的和就是上帝给生命之树的评分。

经过 atm 的努力，他已经知道了上帝给每棵树上每个节点上的整数。
但是由于 atm 不擅长计算，他不知道怎样有效的求评分。
他需要你为他写一个程序来计算一棵树的分数。

***输入格式：***

第一行一个整数 n 表示这棵树有 n 个节点。（0 &lt; n &le; 10<sup>5</sup>）
第二行 n 个整数，依次表示每个节点的评分。（评分绝对值 &le; 10<sup>6</sup>）
接下来 n-1 行，每行 2 个整数 u, v，表示存在一条 u 到 v 的边。由于这是一棵树，所以是不存在环的。

***输出格式：***

输出一行一个数，表示上帝给这棵树的分数。

***样例输入：***

```
5
1 -2 -3 4 5
4 2
3 1
1 2
2 5
```

***样例输出:***

8
