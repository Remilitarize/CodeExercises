[toc]

## 熊怪吃核桃（3 分）

森林里有一只熊怪，很爱吃核桃。
不过它有个习惯，每次都把找到的核桃分成相等的两份，吃掉一份，留一份。
如果不能等分，熊怪就会扔掉一个核桃再分。
第二天再继续这个过程，直到最后剩一个核桃了，直接丢掉。

有一天，熊怪发现了 1543 个核桃，请问，它在吃这些核桃的过程中，一共要丢掉多少个核桃。

## 星系炸弹（5 分）

在 X 星系的广袤空间中漂浮着许多 X 星人造 "炸弹"，用来作为宇宙中的路标。
每个炸弹都可以设定多少天之后爆炸。
比如：阿尔法炸弹 2015 年 1 月 1 日放置，定时为 15 天，则它在 2015 年 1 月 16 日爆炸。
有一个贝塔炸弹，2014 年 11 月 9 日放置，定时为 1000 天，请你计算它爆炸的准确日期。

请填写该日期，格式为 yyyy-mm-dd，即 4 位年份 2 位月份 2 位日期。比如：2015-02-19。
请严格按照格式书写。不能出现其它文字或符号。

## 九数分三组（9 分）

1~9 的数字可以组成 3 个 3 位数，设为：A，B，C。
现在要求满足如下关系：

B = 2 * A
C = 3 * A

请你写出 A 的所有可能答案，数字间用空格分开，数字按升序排列。

## 循环节长度（11 分）

两个整数做除法，有时会产生循环小数，其循环部分称为：循环节。
比如，11 / 13 = 6 => 0.846153846153.....  其循环节为 [846153，共有 6 位。
下面的方法，可以求出循环节的长度。

请仔细阅读代码，并填写划线部分缺少的代码。

```java
public static int f(int n, int m)
{
	n = n % m;	
	Vector v = new Vector();
	
	for(;;)
	{
		v.add(n);
		n *= 10;
		n = n % m;
		if(n==0) return 0;
		if(v.indexOf(n)>=0)  _________________________________ ;  //填空
	}
}
```

## 打印菱形（13 分）

给出菱形的边长，在控制台上打印出一个菱形来。
为了便于比对空格，我们把空格用句点代替。
当边长为 8 时，菱形为：

```
.......*
......*.*
.....*...*
....*.....*
...*.......*
..*.........*
.*...........*
*.............*
.*...........*
..*.........*
...*.......*
....*.....*
.....*...*
......*.*
.......*
```

下面的程序实现了这个功能，但想法有点奇怪。
请仔细分析代码，并填写划线部分缺失的代码。

```java
public class A
{
	public static void f(int n)
	{
		String s = "*";
		for(int i=0; i<2*n-3; i++) s += ".";
		s += "*";
	
		String s1 = s + "\n";
		String s2 = "";
		
		for(int i=0; i<n-1; i++){
			//System.out.println("=>"+s);
			s = "." + _____________________________________ + "*";  //填空
			s1 = s + "\n" + s1;
			s2 += s + "\n";
		}
		System.out.println(s1+s2);		
	}
	
	public static void main(String[] args)
	{
		f(8);
	}
}
```

## 加法变乘法（17 分）

我们都知道：1 + 2 + 3 + ... + 49 = 1225。
现在要求你把其中两个不相邻的加号变成乘号，使得结果为 2015。

比如：
1 + 2 + 3 + ... + 10 * 11 + 12 + ... + 27 * 28 + 29 + ... + 49 = 2015
就是符合要求的答案。

请你寻找另外一个可能的答案，并把位置靠前的那个乘号左边的数字提交（对于示例，就是提交10）。

## 牌型种数（21 分）

小明被劫持到 X 赌城，被迫与其他 3 人玩牌。
一副扑克牌（去掉大小王牌，共 52 张），均匀发给 4 个人，每个人 13 张。
这时，小明脑子里突然冒出一个问题：
如果不考虑花色，只考虑点数，也不考虑自己得到的牌的先后顺序，自己手里能拿到的初始牌型组合一共有多少种呢？

## 移动距离（15 分）

X 星球居民小区的楼房全是一样的，并且按矩阵样式排列。其楼房的编号为 1，2，3...
当排满一行时，从下一行相邻的楼往反方向排号。
比如：当小区排号宽度为 6 时，开始情形如下：

1  2  3  4  5  6
12 11 10 9  8  7
13 14 15 .....

我们的问题是：已知了两个楼号 m 和 n，需要求出它们之间的最短移动距离（不能斜线方向移动）。

***输入格式：***

3 个整数 w m n，空格分开，都在 1 到 10000 范围内。
w 为排号宽度，m n 为待计算的楼号。

***输出格式：***

要求输出一个整数，表示 m n 两楼间最短移动距离。

***样例输入 1：***

6 8 2

***样例输出 1：***

4

***样例输入 2：***

4 7 20

***样例输出 2：***

5

## 垒骰子（31 分）

赌圣atm晚年迷恋上了垒骰子，就是把骰子一个垒在另一个上边，不能歪歪扭扭，要垒成方柱体。
经过长期观察，atm 发现了稳定骰子的奥秘：有些数字的面贴着会互相排斥！
我们先来规范一下骰子：1 的对面是 4，2 的对面是 5，3 的对面是 6。
假设有 m 组互斥现象，每组中的那两个数字的面紧贴在一起，骰子就不能稳定的垒起来。 
atm 想计算一下有多少种不同的可能的垒骰子方式。
两种垒骰子方式相同，当且仅当这两种方式中对应高度的骰子的对应数字的朝向都相同。
由于方案数可能过多，请输出模 10<sup>9</sup> + 7 的结果。

不要小看了 atm 的骰子数量哦～

***输入格式：***

第一行两个整数 n m（0 &lt; n &le; 10<sup>9</sup>，m &le; 36）
n 表示骰子数目
接下来 m 行，每行两个整数 a b，表示 a 和 b 数字不能紧贴在一起。

***输出格式：***

一行一个数，表示答案模 10<sup>9</sup> + 7 的结果。

***样例输入：***

2 1
1 2

***样例输出：***

544

## 垒骰子（25 分）

赌圣atm晚年迷恋上了垒骰子，就是把骰子一个垒在另一个上边，不能歪歪扭扭，要垒成方柱体。
经过长期观察，atm 发现了稳定骰子的奥秘：有些数字的面贴着会互相排斥！
我们先来规范一下骰子：1 的对面是 4，2 的对面是 5，3 的对面是 6。
假设有 m 组互斥现象，每组中的那两个数字的面紧贴在一起，骰子就不能稳定的垒起来。 
atm 想计算一下有多少种不同的可能的垒骰子方式。
两种垒骰子方式相同，当且仅当这两种方式中对应高度的骰子的对应数字的朝向都相同。
由于方案数可能过多，请输出模 10<sup>9</sup> + 7 的结果。

不要小看了 atm 的骰子数量哦～

***输入格式：***

第一行两个整数 n m（0 &lt; n &le; 10<sup>9</sup>，m &le; 36）
n 表示骰子数目
接下来 m 行，每行两个整数 a b，表示 a 和 b 数字不能紧贴在一起。

***输出格式：***

一行一个数，表示答案模 10<sup>9</sup> + 7 的结果。

***样例输入：***

2 1
1 2

***样例输出：***

544

## 灾后重建（31 分）

Pear 市一共有 N（N &le; 50000）个居民点，居民点之间有 M（M &le; 200000）条双向道路相连。这些居民点两两之间都可以通过双向道路到达。这种情况一直持续到最近，一次严重的地震毁坏了全部 M 条道路。
震后，Pear 打算修复其中一些道路，修理第 i 条道路需要 Pi 的时间。不过，Pear 并不打算让全部的点连通，而是选择一些标号特殊的点让他们连通。
Pear 有 Q（Q &le; 50000）次询问，每次询问，他会选择所有编号在 [l, r] 之间，并且 编号 mod K = C 的点，修理一些路使得它们连通。由于所有道路的修理可以同时开工，所以完成修理的时间取决于花费时间最长的一条路，即涉及到的道路中Pi的最大值。

你能帮助 Pear 计算出每次询问时需要花费的最少时间么？这里询问是独立的，也就是上一个询问里的修理计划并没有付诸行动。

***输入格式：***

第一行三个正整数 N、M、Q，含义如题面所述。
接下来 M 行，每行三个正整数 Xi、Yi、Pi，表示一条连接 Xi 和 Yi 的双向道路，修复需要 Pi 的时间。
可能有自环，可能有重边。1 &le; Pi &le; 1000000。
（Li，Ri，Ki均在 [1, N] 范围内，Ci 在 [0, 对应询问的Ki) 范围内。）

接下来 Q 行，每行四个正整数 Li、Ri、Ki、Ci，表示这次询问的点是 [Li,Ri] 区间中所有编号 Mod Ki = Ci的点。
保证参与询问的点至少有两个。

***输出格式：***

输出 Q 行，每行一个正整数表示对应询问的答案。

***样例输入：***

```
7 10 4
1 3 10
2 6 9
4 1 5
3 7 4
3 6 9
1 5 8
2 7 4
3 2 10
1 7 6
7 6 9
1 7 1 0
1 7 3 1
2 5 1 0
3 7 2 1
```

***样例输出:***

9
6
8
8
